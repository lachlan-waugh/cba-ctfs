<!doctype html><html lang=en><head><meta charset=utf-8><title>04: binary exploitation</title>
<meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=../reveal-js/css/reset.css><link rel=stylesheet href=../reveal-js/css/reveal.css><link rel=stylesheet href=../reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=../highlight-js/default.min.css></head><body><div class=reveal><div class=slides><section><h2 id=well-get-started-at-1305>We&rsquo;ll get started at 13:05</h2></section><section data-noprocess data-shortcode-slide class=center><h1 id=binary-exploitation>binary exploitation</h1><h2 id=week04>week04</h2></section><section><h2 id=disclaimer>disclaimer</h2><ul><li>many of the tools and techniques discussed in these sessions could be used against real websites/applications</li><li>don&rsquo;t do that</li></ul></section><section><h2 id=acknowledgement-of-country>acknowledgement of country</h2><ul><li>We begin by acknowledging the Traditional Custodians of the land on which we meet, and pay our respects to their Elders past and present. We extend that arespect to Aboriginal and Torres Strait Islander peoples here today.</li></ul></section><section><section data-shortcode-section><h2 id=what-will-we-cover-this-session>what will we cover this session</h2><ul><li>buffers overflows</li><li>shellcode</li><li>return-oriented programming</li></ul></section></section><section><section data-shortcode-section><h2 id=buffer-overflows>buffer overflows</h2></section><section><h4 id=q-what-happens-if-you-write-more-content-into-a-buffer-than-it-can-store>Q: what happens if you write more content into a buffer than it can store?</h4><p>A. the array resizes to fit the new content</p><p>B. the content gets truncated</p><p>C. an error is thrown</p></section><section><h4 id=q-what-happens-if-you-attempt-to-write-more-content-into-a-buffer-than-it-can-store>Q: what happens if you attempt to write more content into a buffer than it can store?</h4><p>A. the array resizes to fit the new content</p><p>B. the content gets truncated</p><p>C. an error is thrown</p><p><strong>D. the content gets written after the end of the array</strong></p></section><section><h3 id=where-is-this-buffer-stored>Where is this buffer stored?</h3><ul><li><p>buffers are stored on the stack*, next to other variables (& other interesting stuff we&rsquo;ll get to later)</p></li><li><p>so if our content get&rsquo;s written after the end of the array, could we overwrite other variables?</p></li></ul><blockquote><p>*non-malloced buffers</p></blockquote></section><section><h3 id=example>Example</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> input[<span style=color:#ae81ff>40</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> is_admin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gets</span>(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (is_admin) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// idk do something only admins should do
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><section><h2 id=demowill-add-later><a href=will-add-later>Demo</a></h2></section><section><h3 id=what-else-can-we-do-with-it>What else can we do with it?</h3><ul><li><p>what other content might you be able to overwrite?</p></li><li><p>you can basically write until you overwrite something that causes a problem (e.g. a pointer?)</p></li><li><p>what else is stored close to the local variables?</p></li></ul></section><section><h3 id=stack-frame>stack frame?</h3><p><img src=../assets/img/week04/stack-grows-up.png alt></p></section><section><h3 id=then-what>then what?</h3><ul><li><p>what if instead of overwriting the local variables, we overwrote the return address?</p></li><li><p>we could redirect the flow of the application</p></li></ul></section><section><pre tabindex=0><code>    0x18  [  ARGS  ] &lt;- Parameters
    0x14  [  EIP   ] &lt;- Stored Return Pointer
    0x10  [  EBP   ] &lt;- Stored Frame Pointer
    0x0C  [  AAAA  ] &lt;- these are local vars
    0x08  [  AAAA  ]
    0x04  [  AAAA  ]
    0x00  [  AAAA  ]
</code></pre></section><section><p><img src=../assets/img/week04/stack-grows-down.png alt></p></section><section><h2 id=demo>Demo</h2></section></section><section><h3 id=problem>problem!!</h3><p>what if we don&rsquo;t have a basic win function, or useful variable to overwrite?</p></section><section><section data-shortcode-section><h2 id=-shellcode>üêö Shellcode</h2><ul><li>Q: What is a win() function (or any function)?</li></ul></section><section><h2 id=-shellcode-1>üêö Shellcode</h2><ul><li>Q: What is a win() function (or any function)?</li><li>A: It&rsquo;s just a sequence of assembly instructions</li></ul></section><section><h2 id=-shellcode-2>üêö Shellcode</h2><ul><li>Q: What is a win() function (or any function)?</li><li>A: It&rsquo;s just a sequence of assembly instructions<ul><li>Assembly is just bytes</li></ul></li></ul></section><section><h2 id=-shellcode-3>üêö Shellcode</h2><ul><li>Q: What is a win() function (or any function)?</li><li>A: It&rsquo;s just a sequence of assembly instructions<ul><li>Assembly is just bytes</li><li>Bytes is just data (which we can send)</li></ul></li></ul></section><section><h2 id=-shellcode-4>üêö Shellcode</h2><ul><li>Q: What is a win() function (or any function)?</li><li>A: It&rsquo;s just a sequence of assembly instructions<ul><li>Assembly is just bytes</li><li>Bytes is just data (which we can send)</li></ul></li><li>Hence if we can write some assembly instructions, and point EIP at them, we can get code execution (e.g. read/write, pop a shell)!</li></ul></section><section><h3 id=system-calls>system calls</h3><ul><li><p>we cannot directly read/write/open/create files</p></li><li><p>this is handled by the kernel (the operating system)</p></li><li><p>think of it like a function/api, we tell it what to do, it takes over and does it</p></li></ul></section><section><h3 id=registers>registers</h3><ul><li><p>small memory regions located on the CPU</p></li><li><p>RAM is the memory for the current processes</p></li><li><p>registers is the memory for the current instruction</p></li><li><p>what if we manipulated the registers to invoke our own instruction?</p></li></ul></section><section><h3 id=how-do-we-do-that>how do we do that?</h3><blockquote><p><a href=https://cgi.cse.unsw.edu.au/~z5164500/syscall/>linux syscall references</a></p></blockquote></section><section><pre tabindex=0><code>// argv = envp = NULL
xor edx, edx
xor ecx, ecx

// push &#39;/bin/sh&#39; onto stack
push 0x68           
push 0x732f2f2f
push 0x6e69622f
mov ebx, esp

// call execve()
mov eax, 0xb    // Syscall Number 11
int 0x80        // Trigger syscall
</code></pre></section><section><h2 id=demo>Demo</h2></section></section><section><h3 id=problem-1>problem!</h3><p><code>NX</code> (<code>W^X</code>)</p><blockquote><p>regions of memory that are writable, cannot be executable (and vice-versa)</p></blockquote></section><section><section data-shortcode-section><h2 id=return-oriented-programming>Return Oriented Programming</h2></section><section><h3 id=rop>ROP</h3><ul><li><p>Instead of writing our own assembly instruction, we re-use existing instructions from the program.</p></li><li><p>We use instructions preceding a <code>ret</code> (gadgets), so we can jump to them, execute them, and jump back.</p></li><li><p>We chain these gadgets so we can execute a full payload, by: jumping to first one, executing it, jumping back, jumping to the second one, etc.</p></li></ul></section><section><h3 id=gadgets>Gadgets</h3><ul><li>Instructions can comprise of multiple-bytes<ul><li>If jump to an offset within an instructions</li><li>We could have an entirely new instruction</li></ul></li></ul><pre tabindex=0><code>    0xAABBCCDD          0xAABBCCDD      0xAABBCCDD
      ^^^^^^^^              ^^                ^^^^
    MOV EAX, 12         XOR EAX, EAX       INC EAX; CALL WIN
</code></pre><blockquote><p>note, I made those ^^^ up entirely</p></blockquote></section><section><h3 id=old-shellcode>Old shellcode</h3><pre tabindex=0><code>/* argv = envp = NULL */
xor edx, edx
xor ecx, ecx

/* push &#39;/bin/sh&#39; onto stack */
push 0x68
push 0x732f2f2f
push 0x6e69622f
mov ebx, esp

/* call execve() */
mov eax, 0xb /* Syscall Number 11 */
int 0x80     /* Trigger syscall */
</code></pre></section><section><h3 id=how-do-we-replicate-this>How do we replicate this</h3><p><code>execve('/bin/sh', NULL, NULL)</code></p><pre tabindex=0><code>EAX = 0xB # (11)
EBX = address of /bin/sh
ECX = NULL
EDX = NULL

INT 0x80 Syscall
</code></pre></section><section><pre tabindex=0><code>[GADGET_1] # EAX := 0xB # (11)
[GADGET_2] # EBX := address to /bin/sh
[GADGET_3] # ECX := NULL
[GADGET_4] # EDX := NULL
[GADGET_5] # INT 0x80 Syscall
</code></pre></section><section><h3 id=how-do-we-find-gadgets>How do we find gadgets?</h3><ul><li><a href=https://github.com/sashs/Ropper>Ropper</a></li><li><a href=https://github.com/JonathanSalwan/ROPgadget>ROPgadget</a></li><li><a href=https://github.com/Ben-Lichtman/ropr>ropr</a></li></ul></section><section><h2 id=demo>Demo</h2></section></section><section><h2 id=recommended-challenges>Recommended challenges</h2><ul><li><a href=https://exploit.education/phoenix/>exploit.education/pheonix</a></li><li><a href=http://pwnable.kr>pwnable.kr</a></li><li><a href=https://picoctf.org>picoCTF</a></li></ul></section><section><h3 id=next-week>next week</h3><p>reverse engineering</p><ul><li>what if we weren&rsquo;t given the source code?</li><li>static analysis</li><li>dynamic analysis</li></ul></section><section><h2 id=thanks>thanks!</h2><p>that&rsquo;s all :)</p></section></div></div><script type=text/javascript src=../reveal-hugo/object-assign.js></script><a href=../reveal-js/css/print/ id=print-location style=display:none></a><script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>null</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=../reveal-js/js/reveal.js></script><script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=../reveal-js/plugin/markdown/marked.js></script><script type=text/javascript src=../reveal-js/plugin/markdown/markdown.js></script><script type=text/javascript src=../reveal-js/plugin/highlight/highlight.js></script><script type=text/javascript src=../reveal-js/plugin/zoom-js/zoom.js></script><script type=text/javascript src=../reveal-js/plugin/notes/notes.js></script></body></html>